<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA Second Project: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA Second Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a28b997d5f76dfc9f9f859dfb56db71c6"><td class="memItemLeft" align="right" valign="top"><a id="a28b997d5f76dfc9f9f859dfb56db71c6" name="a28b997d5f76dfc9f9f859dfb56db71c6"></a>
<a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>findVertex</b> (const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;in) const</td></tr>
<tr class="separator:a28b997d5f76dfc9f9f859dfb56db71c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec2571dbe14ba5aed58bbc3d201fe8f"><td class="memItemLeft" align="right" valign="top"><a id="a4ec2571dbe14ba5aed58bbc3d201fe8f" name="a4ec2571dbe14ba5aed58bbc3d201fe8f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addVertex</b> (const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;in)</td></tr>
<tr class="separator:a4ec2571dbe14ba5aed58bbc3d201fe8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1363d4450cae7cbf7ecbd5b6fe802b67"><td class="memItemLeft" align="right" valign="top"><a id="a1363d4450cae7cbf7ecbd5b6fe802b67" name="a1363d4450cae7cbf7ecbd5b6fe802b67"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>removeVertex</b> (const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;in)</td></tr>
<tr class="separator:a1363d4450cae7cbf7ecbd5b6fe802b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9f770dc363a54670ac0ea27697aaf4"><td class="memItemLeft" align="right" valign="top"><a id="a5c9f770dc363a54670ac0ea27697aaf4" name="a5c9f770dc363a54670ac0ea27697aaf4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;sourc, const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;dest, double w)</td></tr>
<tr class="separator:a5c9f770dc363a54670ac0ea27697aaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692346652509f8cb2555f838b4acbeda"><td class="memItemLeft" align="right" valign="top"><a id="a692346652509f8cb2555f838b4acbeda" name="a692346652509f8cb2555f838b4acbeda"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>removeEdge</b> (const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;source, const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;dest)</td></tr>
<tr class="separator:a692346652509f8cb2555f838b4acbeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0de049ff043cd9d591a6be5952ee9e"><td class="memItemLeft" align="right" valign="top"><a id="abf0de049ff043cd9d591a6be5952ee9e" name="abf0de049ff043cd9d591a6be5952ee9e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addBidirectionalEdge</b> (const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;sourc, const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;dest, double w)</td></tr>
<tr class="separator:abf0de049ff043cd9d591a6be5952ee9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5e0517e2979c54eebdafc2a9875e8f"><td class="memItemLeft" align="right" valign="top"><a id="abb5e0517e2979c54eebdafc2a9875e8f" name="abb5e0517e2979c54eebdafc2a9875e8f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumVertex</b> () const</td></tr>
<tr class="separator:abb5e0517e2979c54eebdafc2a9875e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6a0f6c89527075ce99ee3d36d7da10"><td class="memItemLeft" align="right" valign="top"><a id="adb6a0f6c89527075ce99ee3d36d7da10" name="adb6a0f6c89527075ce99ee3d36d7da10"></a>
std::unordered_map&lt; unsigned, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexSet</b> () const</td></tr>
<tr class="separator:adb6a0f6c89527075ce99ee3d36d7da10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d6d9c586e9bf2a8278c3e534a18eb3"><td class="memItemLeft" align="right" valign="top"><a id="a45d6d9c586e9bf2a8278c3e534a18eb3" name="a45d6d9c586e9bf2a8278c3e534a18eb3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dfsVisit</b> (<a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt; *v, std::vector&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt; &amp;res) const</td></tr>
<tr class="separator:a45d6d9c586e9bf2a8278c3e534a18eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded2431bddc4c277db7ac08da4486179"><td class="memItemLeft" align="right" valign="top"><a id="aded2431bddc4c277db7ac08da4486179" name="aded2431bddc4c277db7ac08da4486179"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isConnected</b> () const</td></tr>
<tr class="separator:aded2431bddc4c277db7ac08da4486179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8772e80e7715910f0622b57c62015ce4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8772e80e7715910f0622b57c62015ce4">haversine</a> (double lat1, double lon1, double lat2, double lon2) const</td></tr>
<tr class="memdesc:a8772e80e7715910f0622b57c62015ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Haversine distance between two points specified by latitude and longitude. Complexity O(1)  <a href="classGraph.html#a8772e80e7715910f0622b57c62015ce4">More...</a><br /></td></tr>
<tr class="separator:a8772e80e7715910f0622b57c62015ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd0cf107e642f3a8da6f41563be35f4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3bd0cf107e642f3a8da6f41563be35f4">aproxTSP</a> ()</td></tr>
<tr class="memdesc:a3bd0cf107e642f3a8da6f41563be35f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an approximate solution to the TSP using MST and preorder traversal. Complexity O(V + E), where V is the number of vertices and E is the number of edges.  <a href="classGraph.html#a3bd0cf107e642f3a8da6f41563be35f4">More...</a><br /></td></tr>
<tr class="separator:a3bd0cf107e642f3a8da6f41563be35f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347f5980bd8d0e6a113196f6e3ccffef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a347f5980bd8d0e6a113196f6e3ccffef">computeMST</a> (<a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt; *root)</td></tr>
<tr class="memdesc:a347f5980bd8d0e6a113196f6e3ccffef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Minimum Spanning Tree of the graph starting from a given root vertex using Prim's algorithm. Complexity O((V + E) log V), where V is the number of vertices and E is the number of edges.  <a href="classGraph.html#a347f5980bd8d0e6a113196f6e3ccffef">More...</a><br /></td></tr>
<tr class="separator:a347f5980bd8d0e6a113196f6e3ccffef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214d5b9709ccc3c5fa6a0b41171f28dc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a214d5b9709ccc3c5fa6a0b41171f28dc">calculateTriangular</a> (std::vector&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt; g)</td></tr>
<tr class="memdesc:a214d5b9709ccc3c5fa6a0b41171f28dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total weight of a triangular tour through the given points. Complexity O(n), where n is the number of points in the vector.  <a href="classGraph.html#a214d5b9709ccc3c5fa6a0b41171f28dc">More...</a><br /></td></tr>
<tr class="separator:a214d5b9709ccc3c5fa6a0b41171f28dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64024f07403fc18261b3d6c30a6cb25"><td class="memItemLeft" align="right" valign="top"><a id="ac64024f07403fc18261b3d6c30a6cb25" name="ac64024f07403fc18261b3d6c30a6cb25"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getEdgeWeight</b> (const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;a, const <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &amp;b) const</td></tr>
<tr class="separator:ac64024f07403fc18261b3d6c30a6cb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a15ba924c601f35b18fe8335437aae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a34a15ba924c601f35b18fe8335437aae">tspBTRec</a> (unsigned int curIndex, double curDist, std::vector&lt; unsigned int &gt; &amp;curPath, double &amp;minDist, std::vector&lt; unsigned int &gt; &amp;path) const</td></tr>
<tr class="memdesc:a34a15ba924c601f35b18fe8335437aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive helper function for solving the Traveling Salesman Problem using backtracking. Complexity: O(V!)  <a href="classGraph.html#a34a15ba924c601f35b18fe8335437aae">More...</a><br /></td></tr>
<tr class="separator:a34a15ba924c601f35b18fe8335437aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5129f6a2b6eb2f7ceadf6125af6cd3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8a5129f6a2b6eb2f7ceadf6125af6cd3">tspBT</a> (std::vector&lt; unsigned int &gt; &amp;path) const</td></tr>
<tr class="memdesc:a8a5129f6a2b6eb2f7ceadf6125af6cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem using backtracking. Complexity: O(V!)  <a href="classGraph.html#a8a5129f6a2b6eb2f7ceadf6125af6cd3">More...</a><br /></td></tr>
<tr class="separator:a8a5129f6a2b6eb2f7ceadf6125af6cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1956ec0183c9d9c7871b15b91bd1db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aff1956ec0183c9d9c7871b15b91bd1db">tspHeuristic</a> (std::vector&lt; unsigned int &gt; &amp;path) const</td></tr>
<tr class="memdesc:aff1956ec0183c9d9c7871b15b91bd1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the TSP using a heuristic approach based on clustering and greedy traversal. Complexity: O(V^2), where V is the number of vertices in the graph.  <a href="classGraph.html#aff1956ec0183c9d9c7871b15b91bd1db">More...</a><br /></td></tr>
<tr class="separator:aff1956ec0183c9d9c7871b15b91bd1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2e6c233ccffcd39d00c9cb5088021b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2f2e6c233ccffcd39d00c9cb5088021b">getNearestVertex</a> (unsigned int from, const std::unordered_set&lt; unsigned int &gt; &amp;candidates) const</td></tr>
<tr class="memdesc:a2f2e6c233ccffcd39d00c9cb5088021b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nearest vertex from a specified vertex among a set of candidates. Complexity: O(n), where n is the number of candidates.  <a href="classGraph.html#a2f2e6c233ccffcd39d00c9cb5088021b">More...</a><br /></td></tr>
<tr class="separator:a2f2e6c233ccffcd39d00c9cb5088021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdad4adbce1ecae7201b4bda3e5a766d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abdad4adbce1ecae7201b4bda3e5a766d">solveClusterTSP</a> (const std::vector&lt; unsigned int &gt; &amp;cluster, std::vector&lt; unsigned int &gt; &amp;clusterPath) const</td></tr>
<tr class="memdesc:abdad4adbce1ecae7201b4bda3e5a766d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total distance of a tour within a cluster using a greedy algorithm. Complexity: O(V^2), where V is the number of vertices in the cluster.  <a href="classGraph.html#abdad4adbce1ecae7201b4bda3e5a766d">More...</a><br /></td></tr>
<tr class="separator:abdad4adbce1ecae7201b4bda3e5a766d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eb9a1b06d720c9998a85f07ab207c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a89eb9a1b06d720c9998a85f07ab207c8">clustering</a> (std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;clusters, unsigned int k) const</td></tr>
<tr class="memdesc:a89eb9a1b06d720c9998a85f07ab207c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform clustering on the vertices of the graph.  <a href="classGraph.html#a89eb9a1b06d720c9998a85f07ab207c8">More...</a><br /></td></tr>
<tr class="separator:a89eb9a1b06d720c9998a85f07ab207c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e09ada85e9dc40d87366f8012a1252"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a78e09ada85e9dc40d87366f8012a1252">tspRealWorld</a> (std::vector&lt; unsigned int &gt; &amp;path) const</td></tr>
<tr class="memdesc:a78e09ada85e9dc40d87366f8012a1252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Travelling Salesperson Problem (TSP) using a greedy heuristic approach.  <a href="classGraph.html#a78e09ada85e9dc40d87366f8012a1252">More...</a><br /></td></tr>
<tr class="separator:a78e09ada85e9dc40d87366f8012a1252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a89b06e56d06a27d283ed10bc7932d1a6"><td class="memItemLeft" align="right" valign="top"><a id="a89b06e56d06a27d283ed10bc7932d1a6" name="a89b06e56d06a27d283ed10bc7932d1a6"></a>
std::unordered_map&lt; unsigned, <a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexSet</b></td></tr>
<tr class="separator:a89b06e56d06a27d283ed10bc7932d1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3bd0cf107e642f3a8da6f41563be35f4" name="a3bd0cf107e642f3a8da6f41563be35f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd0cf107e642f3a8da6f41563be35f4">&#9670;&nbsp;</a></span>aproxTSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt; Graph::aproxTSP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an approximate solution to the TSP using MST and preorder traversal. Complexity O(V + E), where V is the number of vertices and E is the number of edges. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="classNetworkPoint.html">NetworkPoint</a> objects representing the approximate TSP tour. </dd></dl>

</div>
</div>
<a id="a214d5b9709ccc3c5fa6a0b41171f28dc" name="a214d5b9709ccc3c5fa6a0b41171f28dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214d5b9709ccc3c5fa6a0b41171f28dc">&#9670;&nbsp;</a></span>calculateTriangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::calculateTriangular </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the total weight of a triangular tour through the given points. Complexity O(n), where n is the number of points in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>A vector of <a class="el" href="classNetworkPoint.html">NetworkPoint</a> objects representing the points in the tour. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total weight of the triangular tour. </dd></dl>

</div>
</div>
<a id="a89eb9a1b06d720c9998a85f07ab207c8" name="a89eb9a1b06d720c9998a85f07ab207c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89eb9a1b06d720c9998a85f07ab207c8">&#9670;&nbsp;</a></span>clustering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::clustering </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform clustering on the vertices of the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusters</td><td>A reference to a vector of vectors of unsigned integers. </td></tr>
    <tr><td class="paramname">k</td><td>The number of clusters to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void Complexity: O(V * k), where V is the number of vertices and k is the number of clusters. </dd></dl>

</div>
</div>
<a id="a347f5980bd8d0e6a113196f6e3ccffef" name="a347f5980bd8d0e6a113196f6e3ccffef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347f5980bd8d0e6a113196f6e3ccffef">&#9670;&nbsp;</a></span>computeMST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a> Graph::computeMST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; <a class="el" href="classNetworkPoint.html">NetworkPoint</a> &gt; *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Minimum Spanning Tree of the graph starting from a given root vertex using Prim's algorithm. Complexity O((V + E) log V), where V is the number of vertices and E is the number of edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root vertex from which to start the MST computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGraph.html">Graph</a> representing the MST. </dd></dl>

</div>
</div>
<a id="a2f2e6c233ccffcd39d00c9cb5088021b" name="a2f2e6c233ccffcd39d00c9cb5088021b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2e6c233ccffcd39d00c9cb5088021b">&#9670;&nbsp;</a></span>getNearestVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Graph::getNearestVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nearest vertex from a specified vertex among a set of candidates. Complexity: O(n), where n is the number of candidates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The index of the vertex from which distances are measured. </td></tr>
    <tr><td class="paramname">candidates</td><td>A reference to an unordered set of unsigned integers representing the indices of candidate vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the nearest vertex from the specified vertex. </dd></dl>

</div>
</div>
<a id="a8772e80e7715910f0622b57c62015ce4" name="a8772e80e7715910f0622b57c62015ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8772e80e7715910f0622b57c62015ce4">&#9670;&nbsp;</a></span>haversine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::haversine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Haversine distance between two points specified by latitude and longitude. Complexity O(1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lat1</td><td>Latitude of the first point in degrees. </td></tr>
    <tr><td class="paramname">lon1</td><td>Longitude of the first point in degrees. </td></tr>
    <tr><td class="paramname">lat2</td><td>Latitude of the second point in degrees. </td></tr>
    <tr><td class="paramname">lon2</td><td>Longitude of the second point in degrees. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Haversine distance between the two points in meters. </dd></dl>

</div>
</div>
<a id="abdad4adbce1ecae7201b4bda3e5a766d" name="abdad4adbce1ecae7201b4bda3e5a766d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdad4adbce1ecae7201b4bda3e5a766d">&#9670;&nbsp;</a></span>solveClusterTSP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::solveClusterTSP </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusterPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the total distance of a tour within a cluster using a greedy algorithm. Complexity: O(V^2), where V is the number of vertices in the cluster. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster</td><td>A reference to a vector of unsigned integers representing the indices of vertices in the cluster. </td></tr>
    <tr><td class="paramname">clusterPath</td><td>A reference to a vector of unsigned integers to store the tour path within the cluster. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total distance of the tour within the cluster. </dd></dl>

</div>
</div>
<a id="a8a5129f6a2b6eb2f7ceadf6125af6cd3" name="a8a5129f6a2b6eb2f7ceadf6125af6cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5129f6a2b6eb2f7ceadf6125af6cd3">&#9670;&nbsp;</a></span>tspBT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::tspBT </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem using backtracking. Complexity: O(V!) </p>
<p >This function initializes the necessary variables and calls the recursive helper function <code>tspBTRec</code> to compute the shortest possible route that visits each vertex exactly once and returns to the starting point. It returns the minimum distance of such a path and stores the corresponding path in the provided vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Reference to a vector where the path of the minimum distance will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum distance of the Traveling Salesman Problem solution. </dd></dl>

</div>
</div>
<a id="a34a15ba924c601f35b18fe8335437aae" name="a34a15ba924c601f35b18fe8335437aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a15ba924c601f35b18fe8335437aae">&#9670;&nbsp;</a></span>tspBTRec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tspBTRec </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>curDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>curPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive helper function for solving the Traveling Salesman Problem using backtracking. Complexity: O(V!) </p>
<p >This function attempts to find the shortest path that visits all vertices in the graph exactly once and returns to the starting vertex. It explores all possible paths using backtracking and updates the minimum distance and corresponding path whenever a shorter path is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curIndex</td><td>The current index in the path being constructed. </td></tr>
    <tr><td class="paramname">curDist</td><td>The current total distance of the path being constructed. </td></tr>
    <tr><td class="paramname">curPath</td><td>The current path being constructed. </td></tr>
    <tr><td class="paramname">minDist</td><td>Reference to the minimum distance found so far. </td></tr>
    <tr><td class="paramname">path</td><td>Reference to the path corresponding to the minimum distance found so far. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff1956ec0183c9d9c7871b15b91bd1db" name="aff1956ec0183c9d9c7871b15b91bd1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1956ec0183c9d9c7871b15b91bd1db">&#9670;&nbsp;</a></span>tspHeuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::tspHeuristic </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the TSP using a heuristic approach based on clustering and greedy traversal. Complexity: O(V^2), where V is the number of vertices in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A reference to a vector of unsigned integers to store the resulting TSP path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total distance of the TSP tour. </dd></dl>

</div>
</div>
<a id="a78e09ada85e9dc40d87366f8012a1252" name="a78e09ada85e9dc40d87366f8012a1252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e09ada85e9dc40d87366f8012a1252">&#9670;&nbsp;</a></span>tspRealWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::tspRealWorld </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Travelling Salesperson Problem (TSP) using a greedy heuristic approach. </p>
<p >This function attempts to find a Hamiltonian cycle (if one exists) in a connected graph by iteratively selecting the shortest edge to an unvisited vertex (nearest neighbour). If the graph is not connected, it returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A reference to a vector that will contain the order of visited vertices in the resulting TSP path, starting from the initial vertex. The initial vertex is provided as the first element in this vector. The vector is modified to include the full cycle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total distance of the TSP path. If the graph is not connected or a cycle cannot be formed, it returns -1. Complexity O(V^2), where V is the number of vertices. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Graph_8h_source.html">Graph.h</a></li>
<li>Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
